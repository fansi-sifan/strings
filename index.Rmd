---
title: "Brookings Data Network: String Basics"
author: "Sifan Liu"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    nature:
      ratio: 16:9
---

# Hello!

```{r setup, include = F}
library(xaringanExtra)
xaringanExtra::use_panelset()
knitr::opts_chunk$set(warning=FALSE)
```

### What we will cover:
- What is a string?
- What can we do with strings in R?


???
My name is Sifan Liu, Senior Research Analyst at Brookings Metro. I am also the current co-chair of Brookings Data Network. 
Today, we are going to talk about how to work with strings in R. Our first fifteen minutes will focus on the basics - this will be great for someone who has some data analysis experience in Stata, Excel, but is new to R, or if you are quite familiar with R already, but are mostly self-taught, and would like to have a comprehensive overview of what you could do with strings in R. 

---
# String basics
- They are also known as "text", "characters", etc. 

???
Okay. The first thing you need to know is that strings have many names. You might have heard "text asee "text", "characters" in references, and we use them interchangeably. 
The way to spot them in R is simple - they are always quoted with either single quotes, or double quotes, no difference. 
--

- Strings are always quoted with single quotes `''` or double quotes `""`.
```{r define}
a <- "I am a string"
a
typeof(a)
```

???

For example, Here I created a string by using double quotes around the text. In R, you can use typeof() function to get the type of the object
---
# String basics
```{r}
b <- c("We are", "also strings")
b
```
???
Here's another example - you can also create a vector of characters by using the C function in R, which combines all arguments to form a vector. 
--

```{r}
as.data.frame(b)
```
???
We just showed that when you print a character or a character vector, R always returns the strings with quotes. But that's not the case with dataframes. If we turn the character vector b that we just created to a dataframe, it no longer shows you the quotes. 
--
```{r}
tibble::as_tibble(b)
```

???
That's why I always like to use tibbles - this is also from the tidyverse collections. Tibbles are dataframes, but they have some nice features, including printing the data type of each column
---
# Quiz

.panelset[
.panel[.panel-name[Quiz]

Which of the following object is not a string?

1. TRUE

1. "16"

1. c("a", 30)

1. "\n"


]

.panel[.panel-name[Answer]

```{r error=TRUE}
list <- list(TRUE, "16", c("a", 30), "\n")
purrr::map(list, typeof)
```
]
]

???

Now let's do a quick excercise - please type in the chat, which of the following object is not a string?

The first one is not a string, because it does not have quotes. In fact, this is a special data type, called logical value.

Can anyone tell me why number 3 is also a character - there are no quotes around number 30. (c function coerce all arguments to the simplest type required to represent all information)

---

# Let's clean some strings!

```{r, include = F}
df <- tibble::tribble(
        ~state, ~state_code, ~state_name, ~county_code,          ~county,
          "AL",          1L,   "Alabama ",           1L, "Autauga County",
          "AL",          1L,   "Alabama",           3L, "Baldwin county",
          "AL",          1L,   " Alabama",           5L, "Barbour County",
          "AL",          1L,   "Alabama ",           7L,    "Bibb County",
          "AL",          1L,   "Alabama",           9L,  "Blount COUNTY",
          "AL",          1L,   "Alabama",          11L, "Bullock County"
        )

```

```{r}
library(stringr)  # "str_"
```

???
Now, let's move on to see what we can do with strings, and we will be using the stringr library, which is part of the tidyverse. All the functions in the stringr function starts with "str_", which is easy to navigate. 

--
```{r}
df
```

???

Here's a dataframe containing the name of counties, states, and the respective state code and county code. 
--

```{r length, warning=FALSE}
str_length(df$state_name)
```


???
Please type in the chat, what did you notice from this dataset?
- spaces in state name (copy from Excel)
- county name are in various case (we can use str_length() to quickly show the number of characters in each string - the uneven lengths suggest that there are indeed hidden spaces)
- state code and county code are numeric values - why that might be a problem? (County FIPS codes are five digit, the first two are states, and the next three digits are county. You need all five digits to uniquely identify a county in the US)

---
# Managing length
### str_trim()
removes whitespace from a string
```{r}
df$state_name %>% 
  str_trim()
```

???
To manage the length of a string, you can trim a string, or pad a string with spaces or other characters. 

Let's first look at trim. To remove whitespace from a string, we use str_trim(), you can specify if you want to trim the white space from left, right - the default is both. Now all the state names are of equal length.
--
### str_pad()
pads a string to a new length
```{r}
df$state_name %>% 
  str_pad(width = 8, side = "left", pad = " ")
```

???

In contrast, str_pad allows you to pad a string with a given length.You can specify the expected length of your string, which side to pad, and which characters to pad. In this case I'm adding white spaces to the left to make all the string have a lenghth of eight

---
# Convert case

```{r}
str_to_lower("Blount COUNTY")
str_to_upper("Blount COUNTY")
str_to_title("Blount COUNTY")
```

???
Another useful function is case converstion. Stringr supports three types of case: all lower case, all upper case, or title case, which capitalize the first character of each word. This is very helpful in text analysis, because you want to make sure these variations are recognized as the same word.

---
# Subset and combine
### str_sub()
```{r}
df$county
str_sub(df$county, start = 1, end = -8)

```

???
You could also remove characters at specified positions - if I only want to keep the first part of the county name, I use str_sub to keep the string "start from position 1", which is the first character, to the 8th character counting from the end. Note that you can use the negative sign to specify positions from the end.

--
### str_c()
```{r}
str_c(df$state, ",US")
```


???
In contrast, you can combine strings by using str_c(). Here I am adding "US" to the state names.

---
# Detect and replace
### str_detect()
```{r}
str_detect(df$county, "a")
```

???
Another set of useful functions is detect certain characters, from the string, and you can either extract it, or replace it with another word.
Here I'm using str_detect() to find if any of the county names contain the letter "a".
--

```{r}
df %>% 
  dplyr::filter(str_detect(county, "a"))
```

???
Notice that this function return a vector of T/F, This can be combined with filter function to return the data that meets the criteria. 

---
# Detect and replace
### str_replace()
```{r}
df$county %>% 
  str_to_lower() %>% 
  str_replace("county", "cty")
```

???
Similar to str_detect(), str_extract_all() returns the entire string, instead of just returning the T/F value

You can also modify the part of the string that has been detected, by using str_replace(), and you just need to specify the replacement value. 
---
# Let's code!

---
# What's next?

--

## [stringi](https://stringi.gagolewski.com/)

--

## Regular Expressions
- define more complex search patterns
1. extract all numbers in the strings
2. remove all characters after the last `.`
3. find the string that ends with "s"

--

## Special forms of strings
- Dates and time: [lubridate](https://lubridate.tidyverse.org/)
- Human names: [humaniformat](https://cran.r-project.org/web/packages/humaniformat/vignettes/Introduction.html)
- Addresses: [tidygeocoder](https://cran.r-project.org/web/packages/tidygeocoder/vignettes/tidygeocoder.html)